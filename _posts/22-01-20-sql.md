---
ㄴlayout: single
title: "SQL"
tag: [sql]
toc: true
---



# SQL

> Structured Query Language (SQL)은 데이터베이스 용 프로그래밍 언어
>
> 데이터베이스에 쿼리를 보내 원하는 데이터를 가져오거나 삽입할 수 있다.

### 데이터베이스의 필요성

1. In-Memory

- js에서 변수를 만들어 저장한 경우, 프로그램이 종료될 때 해당 프로그램이 사용하던 데이터도 사라진다. 이 말은 변수 등에 저장한 데이터가 프로그램의 실행에 의존한다는 말이다.

2. File I/O

- 파일을 읽는 방식으로 작동하는 형태를 말한다.(엑셀시트, CSV 등)
- 데이터가 필요할 때마다 전체 파일을 매번 읽어야 하는 단점이 있다.
- 복잡하고 데이터량이 많아질수록 데이터를 불러들이는 작업이 점점 힘들어 진다.

3. SQL

- 반면에, 관계형 데이터베이스에서는 하나의 CSV파일이나 엑셀 시트를 한 개의 테이블로 저장할 수 있다

#### 쿼리

저장되어 있는 데이터를 필터하기 위한 질의문



### 데이터베이스 관련 명령어

**데이터베이스 생성**

```js
	CREATE DATABASE 데이터베이스_이름;
```

**데이터베이스 사용**

데이터베이스를 이용해 테이블을 만들거나 수정하거나 삭제하는 등의 작업을 하려면, 먼저 데이터베이스를 사용하겠다는 명령을 전달해야 한다.

```js
USE 데이터베이스_이름;
```

**테이블 생성**

`USE` 를 이용해 데이터베이스를 선택했다면, 이제 테이블을 만들 수 있다.

```js
CREATE TABLE user (
	id int PRIMARY KEY AUTO_INCREMENT,
  name varchar(255),
  email varchar(255)
);
```

**테이블 정보 확인**

```js
DESCRIBE user;
```

다음과 같이 user 테이블의 정보를 확인할 수 있다.

```
mysql> describe user;
+-------+--------------+------+-----+---------+----------------+
| Field | Type         | Null | Key | Default | Extra          |
+-------+--------------+------+-----+---------+----------------+
| id    | int          | NO   | PRI | NULL    | auto_increment |
| name  | varchar(255) | YES  |     | NULL    |                |
| email | varchar(255) | YES  |     | NULL    |                |
+-------+--------------+------+-----+---------+----------------+
3 rows in set (0.00 sec)
```

​														[예시] user 테이블의 정보를 확인합니다.



### SQL 대표 명령어

**SELECT**

- SELECT는 데이터셋에 포함될 특성을 특정한다.

```js
SELECT 'hello world' // 일반 문자열
SELECT 2 // 숫자
SELECT 15 + 3 // 간단한 연산
```



**FROM**

- 테이블과 관련한 작업을 할 경우 반드시 입력해야 한다. FROM 뒤에는 결과를 도출해낼 데이터베이스 테이블을 명시

```js
// 특정 특성을 테이블에서 사용
SELECT 특성_1
FROM 테이블_이름
// 몇 가지의 특성을 테이블에서 사용
SELECT 특성_1, 특성_2
FROM 테이블_이름
// 테이블의 모든 특성을 선택
SELECT *
FROM 테이블_이름
```



**WHERE**

- 필터 역할을 하는 쿼리문

```js
// 특정 값과 동일한 데이터 찾기
SELECT 특성_1, 특성_2
FROM 테이블_이름
WHERE 특성_1 = "특정 값"

// 특정 값보다 크거나 작은 데이터를 필터할 때에는 '<','>' 비교하는 값을 포함하는 '이상','이하'값은
// '<=', '>='을 사용한다
SELECT 특성_1, 특성_2
FROM 테이블_이름
WHERE 특성_1 > "특정 값"

SELECT 특성_1, 특성_2
FROM 테이블_이름
WHERE 특성_1 <= "특정 값"

// 문자열에서 특정 값과 비슷한 값들을 필터할 때에는 'LIKE'와 '\%'혹은 '\*'를 사용한다.
SELECT 특성_1, 특성_2
FROM 테이블_이름
WHERE 특성_2 LIKE "%특정 문자열%"

// 리스트의 값들과 일치하는 데이터를 필터할 때에는 'IN'을 사용한다
SELECT 특성_1, 특성_2
FROM 테이블_이름
WHERE 특성_2 IN ("특정값_1", "특정값_2")

// 값이 없는 경우 'NULL'을 찾을 때에는 'IS'와 같이 사용한다.
SELECT *
FROM 테이블_이름
WHERE 특성_1 IS NULL

// 값이 없는 경우 제외할 때에는 'NOT'을 추가해 이용한다.
SELECT *
FROM 테이블_이름
WHERE 특성_1 IS NOT NULL
```



**ORDER BY**

- 돌려받는 데이터 결과를 어떤 기준으로 정렬하여 출력할지 결정한다.

```js
// 기본 정렬은 오름차순
SELECT *
FROM 테이블_이름
ORDER BY 특성_1

// 내림차순 정렬
SELECT *
FROM 테이블_이름
ORDER BY 특성_1 DESC
```



**LIMIT**

- 결과로 출력할 데이터의 개수를 정함, 쿼리문에서 사용할 때에 가장 마지막에 추가한다.

```js
// 데이터 결과를 200개만 출력합니다.
SELECT *
FROM 테이블_이름
LIMIT 200
```



**DISTINCE**

- 유니크한 값을 받고 싶을 때에는 ```SELECT DISTINCT``` 를 사용할 수 있다.

```js
// 특성_1을 기준으로 유니크한 값들만 선택한다.
SELECT DISTINCT 특성_1
FROM 테이블_이름
// 특성_1, 특성_2, 특성_3의 유니크한 '조합' 값들을 선택합니다.
SELECT
  DISTINCT
    특성_1
    ,특성_2
    ,특성_3
FROM 테이블_이름
```



***INNER JOIN***

- ```INNER JOIN```  이나```JOIN``` 으로 실행

```js
// 둘 이상의 테이블을 서로 공통된 부분을 기준으로 연결합니다.
SELECT *
FROM 테이블_1
JOIN 테이블_2 ON 테이블_1.특성_A = 테이블_2.특성_B
```



### ACID

> 데이터베이스 내에서 일어나는 하나의 트랜잭션(transaction)의 안전성을 보장하기 위해 필요한 성질



**트랜잭션** 

- 여러 개의 작업을 하나로 묶은 실행 유닛
- 각 트랜잭션은 하나의 특정 작업으로 시작을 해 묶여 있는 모든 작업을 다 완료해야 정상적으로 종료한다.
- 하나의 작업이라도 실패하면, 트랜잭션 실패

- 트랜잭션은 ACID라는 특성을 가지고 있다.



#### Atomicity(원자성)

원자성은 하나의 트랜잭션에 속해있는 모든 작업이 전부 성공하거나 전부 실패해서 결과를 예측할 수 있어야 한다.

A계좌에서 B계좌로 입금을 할 때, A계좌에서 돈이 출금되고 B계좌에서 입금이 된다면, 이 트랜잭션은 성공했다는 거고 만약 하나라도 실패가 뜬다면 실패라고 간주한다.

SQL에서도 특정 쿼리를 실행했는데 부분적으로 실패하는 부분이 있다면, 전부 실패하도록 구현되어 있다.



#### Consistency(일관성)

데이터베이스의 상태가 일관되어야 한다는 성질

하나의 트랜잭션 이전과 이후, 데이터베이스의 상태는 이전과 같이 유효해야 한다. 다시 말해, 트랜잭션이 일어난 이후의 데이터베이스는 데이터베이스의 제약이나 규칙을 만족해야 한다.

다음과 같은 트랜잭션은 일관성을 위반한다.

- 이름 없는 새로운 고객을 추가하는 쿼리
- 기존 고객의 이름을 삭제하는 쿼리

데이터베이스의 유효한 상태는 다를 수 있지만, 데이터의 상태에 대한 일관성은 변하지 않아야 한다.



#### Isolation(격리성, 고립성)

모든 트랜잭션은 다른 트랜잭션으로부터 독립되어야 한다

실제로 동시에 여러 개의 트랜잭션들이 수행될 때, 각 트랜잭션은 고립(격리) 되어 있어 연속으로 실행된 것과 동일한 결과를 나타낸다.

각 트랜잭션은 철저히 독립적이기 때문에, 다른 트랜잭션의 작업 내용을 알 수 없다. 그리고 트랜잭션이 동시에 실행될 때 연속으로 실행될 때의 데이터베이스 상태가 동일해야 한다.



#### Durability(지속성)

하나의 트랜잭션이 성공적으로 수행되었다면, 해당 트랜잭션에 대한 로그가 남아야 한다. 만약 런타임 오류나 시스템 오류가 발생하더라도 해당 기록은 영구적이어야 한다

예를 들어 은행에서 계좌이체를 성공적으로 실행한 뒤에, 해당 은행 데이터베이스에 오류가 발생해 종료되더라도 계좌이체 내역은 기록으로 남아야 한다.



### SQL vs NoSQL

> SQL(구조화 쿼리 언어), NoSQL(비구조화 쿼리 언어)

데이터 베이스는 크게 **관계형 데이터베이스** 와 **비관계형 데이터베이스** 로 구분한다. 관계형 데이터베이스는 SQL을 기반으로 하고, 비관계형 데이터베이스는 NoSQL로 데이터를 다룬다. SQL과 NoSQL은 만들어진 방식, 저장하는 정보의 종류, 그리고 저장하는 방법 등에 차이가 있다.



1. SQL
   - 테이블의 구조와 데이터 타입 등을 사전에 정의하고, 테이블에 정의된 내용에 알맞은 형태의 데이터만 삽입할 수 있다.
   - 행과 열로 구성된 테이블에 데이터를 저장한다.
   - 특정한 형식을 지키기 때문에, 데이터를 정확히 입력했다면 데이터를 사용할 때에는 매우 수월하다.
   - 원하는 정보를 쿼리할 수 있다.
   - 테이블 간의 관계를 직관적으로 파악할 수 있다.
2. NoSQL
   - 주로 데이터가 고정되어 있지 않은 데이터베이스
   - 관계형 데이터베이스는 데이터를 입력할 때 스키마에 맞게 입력해야 하는 반면, NoSQL에서는 데이터를 읽어올 때 스키마에 따라 데이터를 익어 온다.



#### 차이점

**데이터 저장(Storage)**

- NoSQL은 key-value, document, wide-column, graph 등의 방식으로 데이터를 저장한다.
- 관계형 데이터베이스는 SQL을 이용해서 데이터를 테이블에 저장합니다. 미리 작성된 스키마를 기반으로 정해진 형식에 맞게 데이터를 저장해야 한다.

**스키마(Schema)**

- SQL을 사용하려면, 고정된 형식의 스키마가 필요하다. 다시 말해, 처리하려는 데이터 속성별로 열(column)에 대한 정보를 미리 정해두어야 한다. 스키마는 나중에 변경할 수 있지만, 이 경우 데이터베이스 전체를 수정하거나 오프라인(down-time)으로 전환할 필요가 있다.
- NoSQL은 관계형 데이터베이스보다 동적으로 스키마의 형태를 관리할 수 있다. 행을 추가할 때 즉시 새로운 열을 추가할 수 있고, 개별 속성에 대해서 모든 열에 대한 데이터를 반드시 입력하지 않아도 된다.

**쿼리(Querying)**

- 쿼리는 데이터베이스에 대해서 정보를 요청하는 질의문이다. 관계형 데이터베이스는 테이블의 형식과 테이블 간의 관계에 맞춰 데이터를 요청해야 한다. 그래서 정보를 요청할 때, SQL과 같이 구조화된 쿼리 언어를 사용한다.
- 비관계형 데이터베이스의 쿼리는 **데이터 그룹 자체**를 조회하는 것에 초점을 두고 있다. 그래서 구조화되지 않은 쿼리 언어로도 데이터 요청이 가능하다. UnQL(UnStructured Query Language)이라고 말하기도 한다.

**확장성(Scalability)**

- 일반적으로 SQL 기반의 관계형 데이터베이스는 수직적으로 확장한다. 높은 메모리, CPU를 사용하는 확장이라고도 한다. 데이터베이스가 구축된 하드웨어의 성능을 많이 이용하기 때문에 비용이 많이 둔다. 여러 서버에 걸쳐서 데이터베이스의 관계를 정의할 수 있지만, 매우 복잡하고 시간이 많이 소모된다.
- NoSQL로 구성된 데이터베이스는 수평적으로 확장한다. 보다 값싼 서버 증설, 또는 클라우드 서비스 이용하는 확장이라고도 한다. NoSQL 데이터베이스를 위한 서버를 추가적으로 구축하면, 많은 트래픽을 보다 편리하게 처리할 수 있다. 그리고 저렴한 범용 하드웨어나 클라우드 기반의 인스턴스에 NoSQL 데이터베이스를 호스팅 할 수 있어서, 수직적 확장보다 상대적으로 비용이 저렴하s다.





















