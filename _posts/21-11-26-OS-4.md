---
layout: single
title:  "인터럽트"
tag: [CS, OS]
toc: true
---

# 인터럽트

인터럽트란 CPU에서 프로그램을 실행할 때, 입출력 하드웨어 장치나 예외적인 상황이 발생하여 처리가 필요할 경우에  CPU에게 알려서 처리하는 기술이다.



## 필요성

1. 선점형 스케쥴러 선점

   - 프로세스 running 중에 스케쥴러가 이를 중단시키고, 다른 프로세스로 교체하기 위해, 현재 프로세스 실행을 중단시켜야 할 때 사용된다.

   <img src="../images/21-11-26-OS-4/스크린샷 2021-11-27 오전 6.17.42.png" alt="스크린샷 2021-11-27 오전 6.17.42" style="zoom:50%;" />

2. I/O Devices와의 커뮤니케이션

   - 저장매체에서 데이터 처리 완료시, 프로세스를 깨워야함(block stata -> ready state)

3. 예외상황 핸들링

   - CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 장치나 예외적인 상황이 발생했을 때, CPU가 해당 처리를 할 수 있도록 CPU에게 알려서 처리해야 한다.
   - 예시) 입출력 하드웨어 장치이슈 - 파일처리가 끝났다는 것을 운영체제에 알려주기, 운영체제는 해당 프로세스를 block state에서 실행 대기(ready)상태로 프로세스 상태 변경하기
   - 예외상황 - 0으로 나누는 계산이 발생해서, 예외상황을 운영체제에 알려주기, 운영체제가 해당 프로세스 실행 중지/에러 표시



## 주요 인터럽트

1. 계산하는 코드에서 0으로 나누는 코드 실행 시 (Divide-by-Zero Interrupt)

   <img src="../images/21-11-26-OS-4/스크린샷 2021-11-27 오전 6.33.21.png" alt="스크린샷 2021-11-27 오전 6.33.21" style="zoom:50%;" />

2. 타이머 인터럽트

   - 선점형 스케쥴러 선점을 위해 필요

     <img src="../images/21-11-26-OS-4/스크린샷 2021-11-27 오전 6.36.11.png" alt="스크린샷 2021-11-27 오전 6.36.11" style="zoom:50%;" />

3. 입출력(I/O) 인터럽트

<img src="../images/21-11-26-OS-4/스크린샷 2021-11-27 오전 6.37.40.png" alt="스크린샷 2021-11-27 오전 6.37.40" style="zoom:50%;" />



### 인터럽트 종류

- 내부 인터럽트(소프트웨어 인터럽트)
  - 주로 프로그램 내부에서 잘못된 명령 또는 잘못된 데이터 사용시 발생
    - 0으로 나눴을 때
    - 사용자 모드에서 허용되지 않은 명령 또는 공간 접근시
    - 계산 결과가 Overflow/Underflow 날 때
- 외부 인터럽트(하다웨어 인터럽트)
  - 주로 하드웨어에서 발생하는 이벤트(프로그램 외부)
    - 전원 이상
    - 기계 문제
    - **키보드 등 IO 관련 이벤트**
    - **Timer 이벤트**

### 시스템 콜 인터럽트

- 시스템콜 실행을 위해서 강제로 코드에 인터럽트 명령을 넣어, CPU에게 실행시켜야 한다.

- 시스템 콜 실제 코드

  - eax 레지스터에 시스템콜 번호를 넣고,
  - ebx 레지스터에 시스템콜 인자값을 넣고,
  - 소프트웨어 인터럽트 명령을 호출하면서 0x80값을 넘겨줌

  <img src="../images/21-11-26-OS-4/스크린샷 2021-11-27 오전 6.47.05.png" alt="스크린샷 2021-11-27 오전 6.47.05" style="zoom:50%;" />

- 동작 흐름

  - 시스템 콜 인터럽트 명령을 호출하면서 0x80값을 넘겨줌

    1. CPU는 사용자 모드를 커널 모드로 바꿔줌
    2. IDT(Interrupt Descriptor Table)에서 0x80에 해당하는 주소(함수)를 찾아서 실행함
    3. system_call()함수에서 eat  로부터 시스템 콜 번호를 찾아서, 해당 번호에 맞는 시스템콜 함수로 이동
    4. 해당 시스템 콜 함수 실행 후, 다시 커널모드에서 사용자 모드로 변경하고, 다시 해당 프로세스 다음 코드 진행

    <img src="../images/21-11-26-OS-4/스크린샷 2021-11-27 오전 6.51.38.png" alt="스크린샷 2021-11-27 오전 6.51.38" style="zoom:50%;" />

​			

<img src="../images/21-11-26-OS-4/스크린샷 2021-11-27 오전 6.54.55-7963755.png" alt="스크린샷 2021-11-27 오전 6.54.55" style="zoom:50%;" />

위의 설명 처럼 4번까지 프로세스 A를 실행하고 다음 프로세스로 진행할 때,

다시 커널모드로 전환 후 타이머 인터럽트를 통해 프로세스 A 실행시간 만료를 알려서 처리한다.

그 다음에 사용자모드로 전환되어 프로세스 B를 실행한다.

