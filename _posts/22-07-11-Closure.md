---
layout: single
title: "클로저"
tag: [closure]
toc: true
---



# 클로저

> 클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다.



선언된 함수안에 변수와 함수가 선언되어 있다면 그 안에 있는 함수는 내부 함수가 되는 거다.

내부 함수안에서 위에 선언된 변수를 name이라고 한다면, name 변수에 접근할 수 있다.

만약 내부 함수안에 또다른 변수 name이 선언된다면, 그땐 외부변수 name이 아닌 내부함수에 선언된 this.name이 사용되게 된다.



아까 클로저는 어휘적 환경의 조합이라고 했는데, 어휘적 범위 지정과정에서 변수가 어디에서 사용이 되는 지를 알고 싶으면, 그 변수가 어디에서 선언되었는지를 알아야 한다. 중첩된 함수, 즉 내부함수는 외부 범위에서 선언한 변수에도 접근할 수 있다.

모든 클로저에는 세가지 스코프(범위)가 있다.

- 지역범위, 외부함수 범위, 전역범위

- 전역범위는 말그대로 선언된 함수, 변수가 전역범위이고, 
- 외부함수 범위는 그 함수안에 범위가 외부함수 범위, 
- 지역범위는 클로저가 선언된 내부함수 안에 범위를 지역범위라고 한다. 지역범위는 외부함수의 범위에 접근할 수 있다.



```js
function makeFunc() {
      var name = "Mozilla";
      function displayName() {
        alert(name);
      }
      return displayName;
    }

    var myFunc = makeFunc();
    //myFunc변수에 displayName을 리턴함
    //유효범위의 어휘적 환경을 유지
    myFunc();
    //리턴된 displayName 함수를 실행(name 변수에 접근)
```

이 코드는 `displayName()`함수가 실행되기 전에 외부함수인 `makeFunc()`로부터 리턴되어 `myFunc` 변수에 저장된다는 것이다.

몇몇 프로그래밍 언어에서, 함수 안의 지역 변수들은 그 함수가 처리되는 동안에만 존재한다. `makeFunc()` 실행이 끝나면(`displayName`함수가 리턴되고 나면) `name` 변수에 더 이상 접근할 수 없게 될 것으로 예상하는 것이 일반적이다.

하지만 위의 예시와 자바스크립트의 경우는 다르다. 그 이유는 자바스크립트는 함수를 리턴하고, 리턴하는 함수가 클로저를 형성하기 때문이다. 클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다. 이 환경은 클로저가 생성된 시점의 유효 범위 내에 있는 모든 지역 변수로 구성된다. 첫 번째 예시의 경우, `myFunc`은 `makeFunc`이 실행 될 때 생성된 `displayName` 함수의 인스턴스에 대한 참조다. `displayName`의 인스턴스는 변수 `name` 이 있는 어휘적 환경에 대한 참조를 유지한다. 이런 이유로 `myFunc`가 호출될 때 변수 `name`은 사용할 수 있는 상태로 남게 되고 "Mozilla" 가 `alert` 에 전달된다.
